import Mathlib.Tactic.Use
import Mathlib.Tactic.Basic
import Mathlib.Tactic.LeftRight
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Contrapose
import Mathlib.Tactic.NthRewrite
import Mathlib.Init.Function
import Mathlib.Init.Set
import Mathlib.Logic.Equiv.Defs
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Image
import Mathlib.Data.Finset.Card


-- Main source : http://users.cecs.anu.edu.au/~bdm/papers/hypercubes.pdf


/- 
Define latin hypercubes as a set of functions from Fin d to Fin n
latin is defined as in for any line in [n]·µà‚Å∫¬π, there is a unique point in A on that line
NOTE : contrary to the convention, we use 0-indexing here 
and the entry of a point is the 0th coordinate
-/

def is_LatinHypercube {n d : Nat} (A : Set (Fin d ‚Üí Fin n)) : Prop := 
  if H0 : n > 0 ‚àß d > 1 then 
    ‚àÄ f : Fin d ‚Üí Fin n, ‚àÄ x : Fin d, ‚àÉ! a : Fin d ‚Üí Fin n, a ‚àà A ‚àß
      ‚àÄ y : Fin d, x ‚â† y ‚Üí a y = f y 
  else 
    False


structure LatinHypercube (n d : Nat) :=
  (H0 : n > 0 ‚àß d > 1)
  (set : Set (Fin d ‚Üí Fin n))
  (prop : is_LatinHypercube set)

-- def ùìó (n d : Nat) := {_ : LatinHypercube n d}

-- Define Isotopism class
def Blindisotopism {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => œÉ‚Çôd x (a x))}

lemma Blindisotopism.main_imp {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), is_LatinHypercube A ‚Üí is_LatinHypercube (Blindisotopism œÉ‚Çôd A) := by
  intro A
  unfold is_LatinHypercube
  simp only [gt_iff_lt, ne_eq, dite_eq_ite]

  by_cases H0 : n > 0 ‚àß d > 1 <;> simp only [H0, if_true, if_false] ; clear H0
  ¬∑ -- 1.
    rintro HA f x
    specialize HA (Œª x => (œÉ‚Çôd x).symm (f x)) x
    rcases HA with ‚ü®a', ha'1, ha'2‚ü©
    use Œª x => œÉ‚Çôd x (a' x)
    constructor <;> simp only [Blindisotopism, and_imp]
    ¬∑ -- 1.
      refine ‚ü® ‚ü® a', ha'1.1, rfl ‚ü©, ?_ ‚ü© ; clear ha'2
      rintro y' hy'
      rw [ha'1.2 y' hy', Equiv.apply_symm_apply]
      done
    ¬∑ -- 2.
      rintro _ ‚ü®a2, ha2, rfl‚ü© ha1f ; clear ha'1
      suffices h : a2 = a' by rw [h]
      apply ha'2 _ ‚ü® ha2, ?_ ‚ü© ; clear ha'2 a' ha2 A
      rintro y' hy'
      rw [‚Üê (ha1f y' hy'), Equiv.symm_apply_apply]
  done

theorem Blindisotopism.main {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) :
  is_LatinHypercube A ‚Üî is_LatinHypercube (Blindisotopism œÉ‚Çôd A) := by
  refine ‚ü® Blindisotopism.main_imp œÉ‚Çôd A, ?_ ‚ü©
  rintro HA
  have HA' := Blindisotopism.main_imp (Œª x => (œÉ‚Çôd x).symm) (Blindisotopism œÉ‚Çôd A) HA ; clear HA
  suffices H : Blindisotopism (fun x => (œÉ‚Çôd x).symm) (Blindisotopism œÉ‚Çôd A) = A by rw [‚Üê H] ; exact HA'
  ext f ; clear HA'
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.symm_apply_apply]
    exact hf
  ¬∑ -- 2.
    rintro hf
    refine ‚ü® Œª x => (œÉ‚Çôd x) (f x), ‚ü® f, hf, rfl ‚ü©, ?_ ‚ü©
    simp only [Equiv.symm_apply_apply]
  done
  

lemma Blindisotopism.closed_under_comp {n d : Nat} (œÉ‚Çôd1 œÉ‚Çôd2 : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n) ) :
  Blindisotopism œÉ‚Çôd1 (Blindisotopism œÉ‚Çôd2 A) = Blindisotopism (Œª x => Equiv.trans (œÉ‚Çôd2 x) (œÉ‚Çôd1 x)) A := by
  unfold Blindisotopism Equiv.trans
  simp only [Set.mem_setOf_eq, Equiv.coe_fn_mk]
  ext
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    exact ‚ü® a, ha, rfl ‚ü©
  ¬∑ -- 2.
    rintro ‚ü®a, ha, rfl‚ü©
    exact ‚ü® Œª x => (œÉ‚Çôd2 x) (a x), ‚ü® a, ha, rfl ‚ü©, rfl ‚ü©
  done

lemma Blindisotopism.closed_under_inv {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.RightInverse (Blindisotopism œÉ‚Çôd) (Blindisotopism (Œª x => (œÉ‚Çôd x).symm)) := by
  unfold Blindisotopism Equiv.symm Function.RightInverse Function.LeftInverse
  simp only [Set.mem_setOf_eq, Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.coe_fn_mk]
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.symm_apply_apply]
    exact ha
  ¬∑ -- 2.
    rintro ha
    use Œª x => (œÉ‚Çôd x) (f x)
    refine ‚ü® ‚ü® f, ha, rfl ‚ü©, by simp only [Equiv.symm_apply_apply] ‚ü©
  done

lemma Blindisotopism.closed_under_inv1 {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.LeftInverse (Blindisotopism œÉ‚Çôd) (Blindisotopism (Œª x => (œÉ‚Çôd x).symm)) := by
  unfold Blindisotopism Function.LeftInverse
  simp only [Set.mem_setOf_eq, Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.coe_fn_mk]
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.apply_symm_apply]
    exact ha
  ¬∑ -- 2.
    rintro ha
    use Œª x => (œÉ‚Çôd x).symm (f x)
    refine ‚ü® ‚ü® f, ha, rfl ‚ü©, by simp only [Equiv.apply_symm_apply] ‚ü©
  done

class Isotopism (n d : Nat) extends Equiv (LatinHypercube n d) (LatinHypercube n d) where
  (iso : ‚àÉ œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n, toEquiv.toFun = Œª A : (LatinHypercube n d) => 
    ‚ü® A.H0, Blindisotopism œÉ‚Çôd A.set, Blindisotopism.main_imp œÉ‚Çôd A.set A.prop ‚ü©)

@[ext] 
theorem Isotopism.ext {n d : Nat} (T1 T2 : Isotopism n d) : 
  T1.toFun = T2.toFun ‚Üí T1 = T2 := by
  intro h
  have Isotopism.ext_equiv : T1.toEquiv = T2.toEquiv ‚Üí T1 = T2 := by
    rcases T1 with ‚ü® ‚ü® f, f1, tofunf, invfunf ‚ü©, iso‚ÇÅ ‚ü©
    rcases T2 with ‚ü® ‚ü® g, g1, tofung, invfung ‚ü©, iso‚ÇÇ ‚ü© 
    simp only [Equiv.mk.injEq, and_imp]
    rintro h1 h2
    congr
    done
  apply Isotopism.ext_equiv
  ext A
  rw [‚Üê Equiv.toFun_as_coe, ‚Üê Equiv.toFun_as_coe, h]
  

def Isotopism.id {n d : Nat} : Isotopism n d := 
  ‚ü® Equiv.refl (LatinHypercube n d), by use Œª _ => Equiv.refl (Fin n); unfold Blindisotopism; simp; rfl ‚ü©


def Isotopism.comp { n d : Nat} (T1 T2 : Isotopism n d) : Isotopism n d := 
  ‚ü® Equiv.trans T1.toEquiv T2.toEquiv,
    by 
      rcases T1 with ‚ü® equiv1, ‚ü® œÉ‚Çôd1, iso1 ‚ü© ‚ü©
      rcases T2 with ‚ü® equiv2, ‚ü® œÉ‚Çôd2, iso2 ‚ü© ‚ü©
      use Œª x => Equiv.trans (œÉ‚Çôd1 x) (œÉ‚Çôd2 x)
      ext A
      simp only [Equiv.trans]
      rw [Equiv.toFun_as_coe] at iso1 iso2
      rw [iso1, iso2] ; clear iso1 iso2
      simp only [Function.comp_apply, LatinHypercube.mk.injEq]
      rw [Blindisotopism.closed_under_comp œÉ‚Çôd2 œÉ‚Çôd1 A.set]
      rfl
      done
  ‚ü©

def Isotopism.inverse_map {n d : Nat} (T : Isotopism n d) : Isotopism n d := 
  ‚ü® T.toEquiv.symm, by
    rcases T with ‚ü® equiv, ‚ü® œÉ‚Çôd, iso ‚ü© ‚ü©
    use Œª x => (œÉ‚Çôd x).symm
    ext A  
    apply Equiv.injective equiv
    simp only [Equiv.invFun_as_coe, Equiv.toFun_as_coe_apply, Equiv.apply_symm_apply]
    rw [Equiv.toFun_as_coe] at iso
    rw [iso, LatinHypercube.mk.injEq]
    nth_rw 1 [‚Üê Blindisotopism.closed_under_inv1 œÉ‚Çôd A.set]
    done
  ‚ü©

theorem Isotopism.LeftInverse { n d : Nat} (T : Isotopism n d) : Isotopism.comp (Isotopism.inverse_map T) T  = Isotopism.id := by
  unfold Isotopism.comp Isotopism.inverse_map Isotopism.id Equiv.trans Function.comp
  congr <;>
  simp only [Equiv.symm_symm, Equiv.apply_symm_apply] <;>
  rfl

instance {n d : Nat} : Group (Isotopism n d) := by
  refine'
  {
    mul := Œª T1 T2 : Isotopism n d => Isotopism.comp T1 T2
    one := Isotopism.id
    inv := Œª T : Isotopism n d => Isotopism.inverse_map T
    div := Œª T1 T2 : Isotopism n d => Isotopism.comp T1 (Isotopism.inverse_map T2)
    npow := @npowRec _ ‚ü®Isotopism.id‚ü© ‚ü®Œª T1 T2 => Isotopism.comp T1 T2‚ü©
    zpow := @zpowRec _ ‚ü®Isotopism.id‚ü© ‚ü®Œª T1 T2 => Isotopism.comp T1 T2‚ü© ‚ü®Isotopism.inverse_map‚ü©
    mul_left_inv := fun T => Isotopism.LeftInverse T
    .. } <;>
  intros <;>
  ext <;>
  rfl
  done

-------------------------------------------------------------------------------------------

def Blindconjugate {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = a ‚àò œÉ_d}

lemma Blindconjugate.main_imp {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), is_LatinHypercube A ‚Üí is_LatinHypercube (Blindconjugate œÉ_d A) := by
  intro A
  unfold is_LatinHypercube
  simp only [gt_iff_lt, ne_eq, dite_eq_ite]

  by_cases H0 : n > 0 ‚àß d > 1 <;> simp only [H0, if_true, if_false] ; clear H0
  intro HA f x 
  specialize HA (Œª x => f (œÉ_d.symm x)) (œÉ_d x)
  rcases HA with ‚ü®a', ha'1, ha'2‚ü©
  use Œª x => a' (œÉ_d x)
  simp only [and_imp, Blindconjugate]
  constructor
  ¬∑ -- 1.
    refine ‚ü® ‚ü® a', ha'1.1, rfl ‚ü©, ?_ ‚ü© ; clear ha'2
    rintro y' hy' 
    rw [‚Üê EmbeddingLike.apply_eq_iff_eq œÉ_d] at hy'
    rw [ha'1.2 (œÉ_d y') hy', Equiv.symm_apply_apply]
    done
  ¬∑ -- 2.
    rintro _ ‚ü®a, ha, rfl‚ü© haf ; clear ha'1
    unfold Function.comp
    suffices  h : a = a' by rw [h]
    apply ha'2 _ ‚ü® ha, ?_ ‚ü© ; clear ha'2 a' ha A
    rintro y' hy'
    specialize haf (œÉ_d.symm y') (by contrapose! hy' ; rw [hy', Equiv.apply_symm_apply])
    rw [‚Üê haf, Function.comp_apply, Equiv.apply_symm_apply]
  done

theorem Blindconjugate.main {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (A : Set (Fin d ‚Üí Fin n)) :
  is_LatinHypercube A ‚Üî is_LatinHypercube (Blindconjugate œÉ_d A) := by
  refine ‚ü® Blindconjugate.main_imp œÉ_d A, ?_ ‚ü©
  rintro HA
  have HA' := Blindconjugate.main_imp œÉ_d.symm (Blindconjugate œÉ_d A) HA ; clear HA
  suffices H : Blindconjugate œÉ_d.symm (Blindconjugate œÉ_d A) = A by rw [‚Üê H]; exact HA'
  ext f ; clear HA'
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    suffices H : (f ‚àò œÉ_d) ‚àò œÉ_d.symm = f by rw [H] ; exact hf
    ext
    rw [Function.comp_apply, Function.comp_apply, Equiv.apply_symm_apply]
    done
  ¬∑ -- 2.
    rintro hf
    refine ‚ü® fun x => f (œÉ_d x), ‚ü® f, hf, rfl ‚ü©, ?_ ‚ü©
    ext
    simp only [Function.comp_apply, Equiv.apply_symm_apply]
  done

lemma Blindconjugate.closed_under_comp {n d : Nat} (œÉ_d1 œÉ_d2 : Fin d ‚âÉ Fin d) (A : Set (Fin d ‚Üí Fin n) ) :
  Blindconjugate œÉ_d1 (Blindconjugate œÉ_d2 A) = Blindconjugate (Equiv.trans œÉ_d1 œÉ_d2) A := by
  unfold Blindconjugate Equiv.trans
  simp only [Set.mem_setOf_eq, Equiv.coe_fn_mk]
  ext
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    exact ‚ü® a, ha, rfl ‚ü©
  ¬∑ -- 2.
    rintro ‚ü®a, ha, rfl‚ü©
    exact ‚ü® Œª x => a (œÉ_d2 x), ‚ü® a, ha, rfl ‚ü©, rfl ‚ü©
  done
  
lemma Blindconjugate.closed_under_inv {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :
  Function.RightInverse (@Blindconjugate n _ œÉ_d) (@Blindconjugate n _ œÉ_d.symm) := by
  unfold Blindconjugate Function.RightInverse Function.LeftInverse
  simp only [Set.mem_setOf_eq, Equiv.invFun_as_coe, Equiv.toFun_as_coe, Equiv.coe_fn_mk, Function.comp]
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.apply_symm_apply]
    exact ha
  ¬∑ -- 2.
    rintro ha
    exact ‚ü® Œª x => f (œÉ_d x), ‚ü® f, ha, rfl ‚ü©, by simp only [Equiv.apply_symm_apply] ‚ü©
  done

--------------------------------------------------------------------------

-- Define Conjugation class
class Conjugation (n d : Nat) extends Equiv (LatinHypercube n d) (LatinHypercube n d) where
  (œÉ_d : Fin d ‚âÉ Fin d)
  (conj : toEquiv.toFun = Œª A : (LatinHypercube n d) => 
    ‚ü® A.H0, {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A.set, b = a ‚àò œÉ_d}, Blindconjugate.main_imp œÉ_d A.set A.prop ‚ü©)
  (inv_conj : toEquiv.invFun = Œª A : (LatinHypercube n d) => 
    ‚ü® A.H0, {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A.set, b = a ‚àò œÉ_d.symm}, 
      Blindconjugate.main_imp œÉ_d.symm A.set A.prop ‚ü©)

def Blindparatopism {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) 
    (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => (œÉ‚Çôd (œÉ_d x)) ((a (œÉ_d x))))}

lemma Blindparatopism.main_imp {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), is_LatinHypercube A ‚Üí is_LatinHypercube (Blindparatopism œÉ_d œÉ‚Çôd A) := by
  intro A
  unfold is_LatinHypercube
  simp only [gt_iff_lt, ne_eq, dite_eq_ite]

  by_cases H0 : n > 0 ‚àß d > 1
  ¬∑ -- 1.
    simp only [H0, if_true] ; clear H0
    intro HA f x
    specialize HA (Œª x => (œÉ‚Çôd x).symm (f (œÉ_d.symm x))) (œÉ_d x)
    rcases HA with ‚ü®a', ha'1, ha'2‚ü©
    use Œª x => (œÉ‚Çôd (œÉ_d x)) (a' (œÉ_d x))
    unfold Blindparatopism
    constructor
    ¬∑ -- 1.
      simp only ; clear ha'2
      constructor
      ¬∑ -- 1.
        rw [Set.mem_setOf_eq]
        exact ‚ü® a', ha'1.1, rfl ‚ü©
      ¬∑ -- 2.
        rintro y' hy' 
        rw [ha'1.2 (œÉ_d y'), Equiv.symm_apply_apply, Equiv.apply_symm_apply]
        rw [EmbeddingLike.apply_eq_iff_eq]
        exact hy'
      done
    ¬∑ -- 2.
      simp only [and_imp, Set.mem_setOf_eq] ; clear ha'1
      rintro _ ‚ü®a, ha, rfl‚ü© haf
      have : a = a' := by
        apply ha'2 ; clear ha'2 a'
        refine ‚ü® ha, ?_ ‚ü© ; clear ha A
        rintro y' hy'
        specialize haf (œÉ_d.symm y') (by contrapose! hy' ; rw [hy', Equiv.apply_symm_apply])
        rw [‚Üê haf]
        simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply]
        done
      rw [this]
    done
  ¬∑ -- 2.
    simp only [H0, if_false]
  done

theorem Blindparatopism.main {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), is_LatinHypercube A ‚Üî is_LatinHypercube (Blindparatopism œÉ_d œÉ‚Çôd A) := by
  intro A
  constructor
  ¬∑ -- 1.
    exact Blindparatopism.main_imp œÉ_d œÉ‚Çôd A
  ¬∑ -- 2.
    rintro HA
    have HA' := Blindparatopism.main_imp œÉ_d.symm (Œª x => (œÉ‚Çôd (œÉ_d x)).symm) (Blindparatopism œÉ_d œÉ‚Çôd A) HA ; clear HA
    have : Blindparatopism œÉ_d.symm (Œª x => (œÉ‚Çôd (œÉ_d x)).symm) (Blindparatopism œÉ_d œÉ‚Çôd A) = A := by
      unfold Blindparatopism
      ext f
      rw [Set.mem_setOf_eq]
      constructor
      ¬∑ -- 1.
        rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
        simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply]
        exact hf
      ¬∑ -- 2.
        rintro hf
        use Œª x => (œÉ‚Çôd (œÉ_d x)) (f (œÉ_d x))
        constructor
        ¬∑ exact ‚ü® f, hf, rfl ‚ü©
        ¬∑ simp only [Equiv.apply_symm_apply, Equiv.symm_apply_apply]
      done
    rw [‚Üê this]
    exact HA'
    done

-- Define Paratopism class
class Paratopism (n d : Nat) extends Equiv (LatinHypercube n d) (LatinHypercube n d) where
  (œÉ_d : Fin d ‚âÉ Fin d)
  (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n)
  (para : toEquiv.toFun = Œª A : (LatinHypercube n d) => 
    ‚ü® A.H0, {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A.set, b = (Œª x => (œÉ‚Çôd (œÉ_d x)) ((a (œÉ_d x))))}, 
      Blindparatopism.main_imp œÉ_d œÉ‚Çôd A.set A.prop ‚ü©)
  (inv_para : toEquiv.invFun = Œª A : (LatinHypercube n d) => 
    ‚ü® A.H0, Blindparatopism œÉ_d.symm (fun x => (œÉ‚Çôd (œÉ_d x)).symm) A.set, 
      Blindparatopism.main_imp œÉ_d.symm (Œª x => (œÉ‚Çôd (œÉ_d x)).symm) A.set A.prop ‚ü©)

----------------------------------------------------------------------------------------------

instance { n d : Nat} : Group (Isotopism n d) where
  one := ‚ü® Equiv.refl (LatinHypercube n d), Œª x => Equiv.refl (Fin n), by simp; rfl, by simp; rfl ‚ü©
  mul := Œª A B : Isotopism n d => ‚ü® Equiv.trans A.toEquiv B.toEquiv, Œª x => Equiv.trans (A.œÉ‚Çôd x) (B.œÉ‚Çôd x), 
    by ext A1; simp; , ?_ ‚ü©
  inv := Inv.inv
  mul_assoc := by
    intros a b c
    ext A
    simp only [Mul.mul, Function.comp_apply]
    done
  one_mul := by
    intro a
    ext A
    simp only [Mul.mul, Function.comp_apply]
    done
  mul_one := by
    intro a
    ext A
    simp only [Mul.mul, Function.comp_apply]
    done
  mul_left_inv := by
    intro a
    ext A
    simp only [Mul.mul, Inv.inv, Function.comp_apply]
    done
  

/-
"The stabilisers of a latin hypercube L under isotopism, paratopism and isomorphism
are known respectively as the autotopism group, autoparatopism group and automorphism
group of L. We use respectively Is(L), Par(L) and Aut(L) to denote these groups. For
example, Aut(L) = {œÉ ‚àà ‚àÜd+1n | LœÉ = L}."
-/


def single_isotopism {n d : Nat} (œÉ‚Çô : Fin n ‚âÉ Fin n) (y : Fin d) (A : Set (Fin d ‚Üí Fin n)) :
  Set (Fin d ‚Üí Fin n) := 
  {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => if x = y then œÉ‚Çô (a y) else (a x))}

def isotopism.inverse_map {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) :=
  isotopism (Œª x => (œÉ‚Çôd x).symm) A

def isomorphism {n d : Nat} (œÉ‚Çô : Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) :=
  {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = œÉ‚Çô ‚àò a}

def conjugate.inverse_map {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) :=
  conjugate œÉ_d.symm A

def paratopism {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) 
    (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := conjugate œÉ_d (isotopism œÉ‚Çôd A)

def paratopism.raw {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) 
    (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => (œÉ‚Çôd (œÉ_d x)) ((a ‚àò œÉ_d) x))}

def paratopism.inverse_map {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) 
    (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := isotopism.inverse_map œÉ‚Çôd (conjugate.inverse_map œÉ_d A)

def paratopism.inverse_map_raw {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) 
    (A : Set (Fin d ‚Üí Fin n)) : 
  Set (Fin d ‚Üí Fin n) := {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => (œÉ‚Çôd x).symm ((a ‚àò œÉ_d.symm) x))}




structure Isotopism {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :=
  (to_fun : Set (Fin d ‚Üí Fin n) ‚Üí Set (Fin d ‚Üí Fin n))
  (prop : to_fun = Œª A => {b : Fin d ‚Üí Fin n | ‚àÉ a ‚àà A, b = (Œª x => œÉ‚Çôd x (a x))})




structure conjugate_equiv {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :=
  (to_fun : Set (Fin d ‚Üí Fin n) ‚Üí Set (Fin d ‚Üí Fin n))
  (inv_fun : Set (Fin d ‚Üí Fin n) ‚Üí Set (Fin d ‚Üí Fin n))
  (fun_def : to_fun = conjugate œÉ_d)
  (inv_def : inv_fun = conjugate œÉ_d.symm)
  (left_inv : Function.LeftInverse inv_fun to_fun)
  (right_inv : Function.RightInverse inv_fun to_fun)

structure paratopism_equiv {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :=
  (to_fun : Set (Fin d ‚Üí Fin n) ‚Üí Set (Fin d ‚Üí Fin n))
  (inv_fun : Set (Fin d ‚Üí Fin n) ‚Üí Set (Fin d ‚Üí Fin n))
  (prop : to_fun = paratopism œÉ_d œÉ‚Çôd)
  (prop_inv : inv_fun = paratopism.inverse_map œÉ_d œÉ‚Çôd)
  (left_inv : Function.LeftInverse inv_fun to_fun)
  (right_inv : Function.RightInverse inv_fun to_fun)

-- composite defintion of paratopism and the direct definition are equivalent
lemma paratopism.raw.main {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), paratopism.raw œÉ_d œÉ‚Çôd A = paratopism œÉ_d œÉ‚Çôd A := by
  intro A
  ext f
  simp [paratopism.raw, paratopism, conjugate, isotopism, Function.comp_apply]
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ha, rfl‚ü©
    use Œª x => (œÉ‚Çôd x) (a x)
    refine ‚ü® ?_, by ext x; rw [Function.comp_apply] ‚ü©
    exact ‚ü® a, ha, rfl ‚ü©
  ¬∑ -- 2.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    exact ‚ü® a, ha, by ext x; rw [Function.comp_apply] ‚ü©
  done

-- composite definition of paratopism.inverse_map and the direct definition are equivalent
lemma paratopism.inverse_map_raw.main {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) 
  (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  ‚àÄ A : Set (Fin d ‚Üí Fin n), paratopism.inverse_map_raw œÉ_d œÉ‚Çôd A = 
    paratopism.inverse_map œÉ_d œÉ‚Çôd A := by
  intro A
  ext f
  simp [paratopism.inverse_map_raw, paratopism.inverse_map, conjugate.inverse_map, 
        isotopism.inverse_map, Function.comp_apply, isotopism, conjugate]
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ha, rfl‚ü©
    use Œª x => a (œÉ_d.symm x)
    refine ‚ü® ?_, rfl ‚ü©
    exact ‚ü® a, ha, by ext x; rw [Function.comp_apply] ‚ü©
  ¬∑ -- 2.
    rintro ‚ü®_, ‚ü® a, ha, rfl ‚ü©, rfl‚ü©
    exact ‚ü® a, ha, by ext x; rw [Function.comp_apply] ‚ü©
  done


-- isomorphism and single_isotopism are the just a specific case of isotopism
lemma isomorphism.isotopism {n d : Nat} (œÉ‚Çô : Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) :
  isomorphism œÉ‚Çô A = isotopism (Œª _ => œÉ‚Çô) A := by
  unfold isomorphism isotopism
  ext f
  constructor <;>
  ¬∑ -- both cases needs exactly the same proof
    simp only [Set.mem_setOf_eq, forall_exists_index, and_imp]
    rintro a ha rfl
    refine ‚ü® a, ha, ?_ ‚ü© ; clear ha
    ext x
    simp only [Function.comp_apply]
    done

lemma single_isotopism.isotopism {n d : Nat} (œÉ‚Çô : Fin n ‚âÉ Fin n) (y : Fin d) 
    (A : Set (Fin d ‚Üí Fin n)) :
  single_isotopism œÉ‚Çô y A = isotopism (Œª x => if x =y then œÉ‚Çô else Equiv.refl (Fin n)) A := by
  unfold single_isotopism isotopism
  ext f
  constructor <;>
  ¬∑ -- both cases needs exactly the same proof
    simp only [Set.mem_setOf_eq, forall_exists_index, and_imp]
    rintro a ha rfl
    refine ‚ü® a, ha, ?_ ‚ü© ; clear ha
    ext x
    by_cases h : x = y <;>
    simp only [h, Function.comp_apply, if_true, if_false, Equiv.refl_apply]
    done



-- small lemmas
@[simp]
lemma comp_equiv_symm {Œ± Œ≤ Œ≥ : Type _} (f : Œ≤ ‚Üí Œ≥) (œÉ : Œ± ‚âÉ Œ≤) : (f ‚àò œÉ) ‚àò œÉ.symm = f := by
  ext x
  rw [Function.comp_apply, Function.comp_apply, Equiv.apply_symm_apply]
  done

@[simp]
lemma comp_symm_equiv {Œ± Œ≤ Œ≥ : Type _} (f : Œ± ‚Üí Œ≥) (œÉ : Œ± ‚âÉ Œ≤) : (f ‚àò œÉ.symm) ‚àò œÉ = f := by
  ext x
  simp only [Function.comp_apply, Equiv.symm_apply_apply]
  done

-- Isotopism is an equivalence relation
lemma isotopism.left_inverse {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.LeftInverse (isotopism.inverse_map œÉ‚Çôd) (isotopism œÉ‚Çôd) := by
  unfold isotopism inverse_map Function.LeftInverse
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.symm_apply_apply]
    exact hf
    done
  ¬∑ -- 2.
    rintro hf
    use Œª x => (œÉ‚Çôd x) (f x)
    simp only [Equiv.symm_apply_apply, and_true]
    exact ‚ü® f, hf, rfl ‚ü©
    done

lemma isotopism.right_inverse {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.RightInverse (isotopism.inverse_map œÉ‚Çôd) (isotopism œÉ‚Çôd) := by
  unfold isotopism inverse_map Function.RightInverse Function.LeftInverse
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    simp only [Equiv.apply_symm_apply]
    exact hf
    done
  ¬∑ -- 2.
    rintro hf
    use Œª x => (œÉ‚Çôd x).symm (f x)
    simp only [Equiv.apply_symm_apply, and_true]
    exact ‚ü® f, hf, rfl ‚ü©
    done

theorem isotopism.Equiv {n d : Nat} (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Equiv (Set (Fin d ‚Üí Fin n)) (Set (Fin d ‚Üí Fin n)) := by
  refine ‚ü® isotopism œÉ‚Çôd, isotopism.inverse_map œÉ‚Çôd, ?_, ?_ ‚ü©
  exact isotopism.left_inverse œÉ‚Çôd
  exact isotopism.right_inverse œÉ‚Çôd
  done

-- Conjugation is an equivalence relation
lemma conjugate.left_inverse {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :
  Function.LeftInverse (@conjugate.inverse_map n d œÉ_d) (conjugate œÉ_d) := by
  unfold conjugate inverse_map Function.LeftInverse
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    rw [comp_equiv_symm f œÉ_d]
    exact hf
    done
  ¬∑ -- 2.
    rintro hf
    use Œª x => f (œÉ_d x)
    constructor
    ¬∑ -- 1.
      refine ‚ü® f, hf, ?_ ‚ü©
      ext x
      rw [Function.comp_apply]
      done
    ¬∑ -- 2.
      ext x
      rw [Function.comp_apply, Equiv.apply_symm_apply]
      done
  done

lemma conjugate.right_inverse {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :
  Function.RightInverse (@conjugate.inverse_map n d œÉ_d) (conjugate œÉ_d) := by
  unfold conjugate inverse_map Function.RightInverse Function.LeftInverse
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü®a, ‚ü® f, hf, rfl ‚ü©, rfl‚ü©
    rw [comp_symm_equiv f œÉ_d]
    exact hf
    done
  ¬∑ -- 2.
    rintro hf
    use Œª x => f (œÉ_d.symm x)
    constructor
    ¬∑ -- 1.
      refine ‚ü® f, hf, ?_ ‚ü©
      ext x
      rw [Function.comp_apply]
      done
    ¬∑ -- 2.
      ext x
      rw [Function.comp_apply, Equiv.symm_apply_apply]
      done
  done

@[simp]
theorem conjugate.Equiv {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) :
  Equiv (Set (Fin d ‚Üí Fin n)) (Set (Fin d ‚Üí Fin n)) := by
  refine ‚ü® conjugate œÉ_d, conjugate.inverse_map œÉ_d, ?_, ?_ ‚ü©
  exact conjugate.left_inverse œÉ_d
  exact conjugate.right_inverse œÉ_d
  done

-- Paratopism is an equivalence relation
lemma paratopism.left_inverse {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.LeftInverse (paratopism.inverse_map œÉ_d œÉ‚Çôd) (paratopism œÉ_d œÉ‚Çôd) := by
  unfold paratopism inverse_map Function.LeftInverse isotopism 
  unfold conjugate isotopism.inverse_map conjugate.inverse_map
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü® _, ‚ü® _, ‚ü® _, ‚ü® a, H, rfl ‚ü©, rfl ‚ü©, rfl ‚ü©, rfl ‚ü©
    simp only [Function.comp_apply, Equiv.apply_symm_apply, Equiv.symm_apply_apply]
    exact H
  ¬∑ -- 2.
    rintro H
    exact ‚ü® Œª x => (œÉ‚Çôd x) (f x), 
            ‚ü® Œª x => (œÉ‚Çôd (œÉ_d x)) (f (œÉ_d x)), 
              ‚ü® Œª x => (œÉ‚Çôd x) (f x), 
                ‚ü® f, H, rfl ‚ü©, 
                rfl 
              ‚ü©, 
              (by ext x ; simp) 
            ‚ü©, 
            (by ext x ; simp) 
          ‚ü©
    done
  done

lemma paratopism.right_inverse {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Function.RightInverse (paratopism.inverse_map œÉ_d œÉ‚Çôd) (paratopism œÉ_d œÉ‚Çôd) := by
  unfold paratopism inverse_map Function.RightInverse Function.LeftInverse
  rintro A
  ext f
  constructor
  ¬∑ -- 1.
    rintro ‚ü® _, ‚ü® _, ‚ü® _, ‚ü® a, H, rfl ‚ü©, rfl ‚ü©, rfl ‚ü©, rfl ‚ü©
    simp
    have : (fun x => a (œÉ_d.symm x)) ‚àò ‚ÜëœÉ_d = a := by
      ext y
      simp only [Function.comp_apply, Equiv.symm_apply_apply]
      done
    rw [this]
    exact H
    done
  ¬∑ -- 2.
    rintro H
    exact ‚ü® Œª x => f (œÉ_d.symm x),
            ‚ü® Œª x => (œÉ‚Çôd x).symm (f (œÉ_d.symm x)),
              ‚ü® Œª x => (f (œÉ_d.symm x)),
                ‚ü® f, H, rfl ‚ü©,
                rfl
              ‚ü©, 
              (by ext x ; simp)
            ‚ü©, 
            (by ext x ; simp)
          ‚ü©
    done

@[simp]
theorem paratopism.Equiv {n d : Nat} (œÉ_d : Fin d ‚âÉ Fin d) (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) :
  Equiv (Set (Fin d ‚Üí Fin n)) (Set (Fin d ‚Üí Fin n)) := by
  refine ‚ü® paratopism œÉ_d œÉ‚Çôd, paratopism.inverse_map œÉ_d œÉ‚Çôd, ?_, ?_ ‚ü©
  exact paratopism.left_inverse œÉ_d œÉ‚Çôd
  exact paratopism.right_inverse œÉ_d œÉ‚Çôd
  done


-- Isotopism, conjugation and paratopism each are closed under composition
lemma isotopism.comp {n d : Nat} {œÉ‚Çôd1 œÉ‚Çôd2 : Fin d ‚Üí Fin n ‚âÉ Fin n} {A : Set (Fin d ‚Üí Fin n)} :
  True := by
  rintro ‚ü®a, ha, rfl‚ü© ‚ü®b, hb, rfl‚ü©
  use Œª x => (œÉ‚Çôd x) (a (b x))
  
  constructor
  ¬∑ -- 1.
    refine ‚ü® a (b x), ?_, ?_ ‚ü©
    exact ‚ü® a, ha, rfl ‚ü©
    exact ‚ü® b, hb, rfl ‚ü©
    done
  ¬∑ -- 2.
    ext x
    simp only [Function.comp_apply]
    done
  done

-- Isotopism, conjugation and paratopism preserve the property of being a latin hypercube

-- Proof Strategy :
-- f                         Profit!
-- |                           ‚Üë
--undo permunation         permutation
-- ‚Üì                           |
-- f'  -Find the point in A ‚Üí  a'


theorem single_isotopism.main {n d : Nat} {H : ùìó n d} (œÉ‚Çô : Fin n ‚âÉ Fin n) (y : Fin d) 
  (A : Set (Fin d ‚Üí Fin n)) :
  A ‚àà H.set ‚Üî single_isotopism œÉ‚Çô y A ‚àà H.set := by 
  rw [single_isotopism.isotopism œÉ‚Çô y A, ‚Üê isotopism.main]

theorem isomorphism.main {n d : Nat} {H : ùìó n d} (œÉ‚Çô : Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) :
  A ‚àà H.set ‚Üî isomorphism œÉ‚Çô A ‚àà H.set := by rw [isomorphism.isotopism œÉ‚Çô A, ‚Üê isotopism.main]


lemma paratopism.main_imp {n d : Nat} {H : ùìó n d} (œÉ_d : Fin d ‚âÉ Fin d) 
  (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) :
  A ‚àà H.set ‚Üí paratopism œÉ_d œÉ‚Çôd A ‚àà H.set := by
  unfold paratopism
  rintro HA
  apply conjugate.main_imp œÉ_d (isotopism œÉ‚Çôd A)
  apply isotopism.main_imp œÉ‚Çôd A
  exact HA
  done

theorem paratopism.main {n d : Nat} {H : ùìó n d} (œÉ_d : Fin d ‚âÉ Fin d) 
  (œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n) (A : Set (Fin d ‚Üí Fin n)) :
  A ‚àà H.set ‚Üî paratopism œÉ_d œÉ‚Çôd A ‚àà H.set := by
  constructor
  ¬∑ -- 1.
    exact paratopism.main_imp œÉ_d œÉ‚Çôd A
    done
  ¬∑ -- 2.
    unfold paratopism
    rintro HA
    rw [‚Üê isotopism.left_inverse œÉ‚Çôd A]
    apply isotopism.main_imp (Œª x => (œÉ‚Çôd x).symm) (isotopism œÉ‚Çôd A)
    rw [‚Üê conjugate.left_inverse œÉ_d (isotopism œÉ‚Çôd A)]
    apply conjugate.main_imp œÉ_d.symm (conjugate œÉ_d (isotopism œÉ‚Çôd A)) 
    exact HA


-- Quotienting by the equivalence relation

def isotopism.relation {n d : Nat} : Set (Fin d ‚Üí Fin n) ‚Üí 
  Set (Fin d ‚Üí Fin n) ‚Üí Prop := 
  Œª A B => ‚àÉ œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n, isotopism œÉ‚Çôd A = B

lemma isotopism.relation.refl {n d : Nat} : Reflexive (@isotopism.relation n d) := by
  rintro A
  use Œª _ => Equiv.refl (Fin n)
  simp only [isotopism, Equiv.refl_apply, exists_eq_right', Set.setOf_mem_eq]
  done

lemma isotopism.relation.symm {n d : Nat} : ‚àÄ {x y : Set (Fin d ‚Üí Fin n)}, 
  isotopism.relation x y ‚Üí isotopism.relation y x  := by
  rintro A B ‚ü®œÉ‚Çôd, rfl‚ü©
  use Œª x => (œÉ‚Çôd x).symm
  apply isotopism.left_inverse
  done

lemma isotopism.relation.trans {n d : Nat} : ‚àÄ {x y z : Set (Fin d ‚Üí Fin n)}, 
  isotopism.relation x y ‚Üí isotopism.relation y z ‚Üí isotopism.relation x z := by
  rintro A B C ‚ü®œÉ‚Çôd, rfl‚ü© ‚ü®œÑ‚Çôd, rfl‚ü©
  use Œª x => Equiv.trans (œÉ‚Çôd x) (œÑ‚Çôd x)
  ext f
  constructor <;> 
  simp only [isotopism, Equiv.trans_apply, Set.mem_setOf_eq, forall_exists_index, and_imp]
  ¬∑ -- 1.
    rintro a1 ha1 rfl
    use fun x => (œÉ‚Çôd x) (a1 x)
    exact ‚ü® ‚ü® a1, ha1, rfl ‚ü©, rfl ‚ü©
  ¬∑ -- 2.
    rintro _ a ha rfl rfl
    refine ‚ü® a, ha, rfl ‚ü©
    done
  done

def isotopism.relation.setoid {n d : Nat} : Setoid (Set (Fin d ‚Üí Fin n)) :=
‚ü® 
  isotopism.relation, 
  ‚ü® isotopism.relation.refl, isotopism.relation.symm, isotopism.relation.trans ‚ü©
‚ü©

def isotopism.class (n d : Nat) := 
  Quotient (isotopism.relation.setoid : Setoid (Set (Fin d ‚Üí Fin n)))


def conjugate.relation {n d : Nat} : Set (Fin d ‚Üí Fin n) ‚Üí 
  Set (Fin d ‚Üí Fin n) ‚Üí Prop := 
  Œª A B => ‚àÉ œÉ_d : Fin d ‚âÉ Fin d, conjugate œÉ_d A = B

lemma conjugate.relation.refl {n d : Nat} : Reflexive (@conjugate.relation n d) := by
  rintro A
  use Equiv.refl (Fin d)
  simp only [conjugate, Equiv.coe_refl, Function.comp.right_id, exists_eq_right', Set.setOf_mem_eq]
  done

lemma conjugate.relation.symm {n d : Nat} : ‚àÄ {x y : Set (Fin d ‚Üí Fin n)}, 
  conjugate.relation x y ‚Üí conjugate.relation y x  := by
  rintro A B ‚ü®œÉ_d, rfl‚ü©
  use œÉ_d.symm
  apply conjugate.left_inverse
  done

lemma conjugate.relation.trans {n d : Nat} : ‚àÄ {x y z : Set (Fin d ‚Üí Fin n)},
  conjugate.relation x y ‚Üí conjugate.relation y z ‚Üí conjugate.relation x z := by
  rintro A B C ‚ü®œÉ_d, rfl‚ü© ‚ü®œÑ_d, rfl‚ü©
  use Equiv.trans œÑ_d œÉ_d 
  ext f
  constructor <;>
  simp
  ¬∑ -- 1.
    rintro ‚ü® a, ha, rfl ‚ü©
    use a ‚àò œÉ_d
    constructor
    ¬∑ exact ‚ü® a, ha, rfl ‚ü©
    ¬∑ ext x ; simp
  ¬∑ -- 2.
    rintro ‚ü® _, ‚ü® a, ha, rfl ‚ü©, rfl ‚ü©
    exact ‚ü® a, ha, rfl ‚ü©
  done

def conjugate.relation.setoid {n d : Nat} : Setoid (Set (Fin d ‚Üí Fin n)) :=
‚ü® 
  conjugate.relation,
  ‚ü® conjugate.relation.refl, conjugate.relation.symm, conjugate.relation.trans ‚ü©
‚ü©

def conjugate.class (n d : Nat) := 
  Quotient (conjugate.relation.setoid : Setoid (Set (Fin d ‚Üí Fin n)))


def paratopism.relation {n d : Nat} : Set (Fin d ‚Üí Fin n) ‚Üí
  Set (Fin d ‚Üí Fin n) ‚Üí Prop := 
  Œª A B => ‚àÉ œÉ_d : Fin d ‚âÉ Fin d, ‚àÉ œÉ‚Çôd : Fin d ‚Üí Fin n ‚âÉ Fin n, 
    paratopism œÉ_d œÉ‚Çôd A = B
  
lemma paratopism.relation.refl {n d : Nat} : Reflexive (@paratopism.relation n d) := by
  rintro A
  use Equiv.refl (Fin d)
  use Œª _ => Equiv.refl (Fin n)
  simp only [paratopism, conjugate, isotopism, Equiv.refl_apply, exists_eq_right', Set.setOf_mem_eq, Equiv.coe_refl,
    Function.comp.right_id]
  done

lemma paratopism.relation.symm {n d : Nat} : ‚àÄ {x y : Set (Fin d ‚Üí Fin n)},
  paratopism.relation x y ‚Üí paratopism.relation y x  := by
  rintro A B ‚ü®œÉ_d, ‚ü®œÉ‚Çôd, rfl‚ü©‚ü©
  use œÉ_d
  use Œª x => (œÉ‚Çôd (œÉ_d x))
  nth_rw 2 [‚Üê paratopism.left_inverse œÉ_d œÉ‚Çôd A]
  ext f
  constructor <;>
  simp only [paratopism, conjugate, isotopism, Set.mem_setOf_eq, inverse_map, isotopism.inverse_map,
    conjugate.inverse_map, forall_exists_index, and_imp]
  ¬∑ -- 1.
    rintro a1 a2 a3 a4 ha4 ha3 ha2 rfl hf 
    use fun x => (œÉ‚Çôd x) (f x)
    refine ‚ü® ?_, by simp ‚ü©
    use fun x => (œÉ‚Çôd (œÉ_d x)) (f (œÉ_d x))
    refine ‚ü® ?_, by ext x; simp ‚ü©
    use fun x => (œÉ‚Çôd x) (f x)
    refine ‚ü® ?_, by ext x; simp ‚ü©
    use a4
    refine ‚ü® ha4, ?_ ‚ü©
    

    rintro _ _ _ a hx rfl rfl rfl rfl
    use a
    constructor
    ¬∑ -- 1.
      refine ‚ü® a ‚àò ‚ÜëœÉ_d, ?_, by simp ‚ü©
      refine ‚ü® a, ?_, rfl ‚ü©
      
      done
    ¬∑ -- 2.
      simp
      
      done
    done
  done

